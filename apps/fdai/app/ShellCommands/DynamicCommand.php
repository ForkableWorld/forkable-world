<?php
/*
*  GNU General Public License v3.0
*  Contributors: ADD YOUR NAME HERE, Mike P. Sinn
 */

namespace App\ShellCommands;
use App\Computers\JenkinsSlave;
use App\Logging\ConsoleLog;
use App\Logging\QMLog;
use App\QMTerminal;
use App\Traits\LoggerTrait;
use App\Types\QMArr;
use App\Types\QMStr;
use Symfony\Component\Process\Process;
use TitasGailius\Terminal\Builder;
use TitasGailius\Terminal\Response;
/**
 * @mixin Process
 */
class DynamicCommand extends Builder {
	use LoggerTrait;
	public $commandLine;
	public $outputString;
	public int $code;
	protected ?JenkinsSlave $executor = null;
	private $obfuscate;
	private $outputEveryLineLive = false;
	private $outputLines = [];
	private array $rawOutputLines;
	private $expectedErrorMessages = [
		'error',
		'warning',
	];
	private string $errorOutput;
	private Response $response;
	/**
	 * @param null $command
	 * @param string|null $cwd
	 * @param array|null $env
	 * @param null $input
	 * @param float|int|null $timeout
	 * @param bool|null $obfuscate
	 * @param JenkinsSlave|null $executor
	 * $command, string $cwd = null, array $env = null, $input = null, ?float $timeout = 60
	 */
	public function __construct($command = null, string $cwd = null, array $env = null, $input = null, ?float $timeout = 60,
	                            bool $obfuscate = null, JenkinsSlave $executor = null){
		$this->obfuscate = $obfuscate;
		$this->input = $command ?? $input;
		$this->cwd = $cwd;
		$this->environmentVariables = $env;
		$this->timeout = $timeout;
		$this->executor = $executor;
	}
	public function run($command = null, callable $output = null): Response{
		return $this->response = parent::run($command, $output); // TODO: Change the autogenerated stub
	}
	/**
	 * @return string
	 */
	public function getLastLine(): string{
		$lines = $this->getOutputLines();
		return end($lines);
	}
	public function logOutput(){
		ConsoleLog::info("CMD: ".$this->getCommandLine());
		$out = $this->getOutputString();
		$out =
			str_replace("Xdebug: [Step Debug] Could not connect to debugging client. Tried: 127.0.0.1:9003 (fallback through xdebug.client_host/xdebug.client_port) :-(",
			            "", $out);
		ConsoleLog::info("OUTPUT: $out");
	}
	/**
	 * @return string
	 */
	public function getCommandLine(): string{
		if(empty($this->commandLine)){
			le("no command!");
		}
		return $this->commandLine;
	}
	/**
	 * @return string
	 */
	public function getOutputString(): string{
		return $this->outputString = $this->response->output();
	}
	/**
	 * @return array
	 */
	public function getOutputLines(): array{
		$arr = $this->response->lines();
		$lines = QMArr::removeEmptyStrings($arr);
		return $lines;
	}
	/**
	 * @throws CommandFailureException
	 * @throws OfflineException
	 */
	public function runOnExecutor(): void{
		if($this->executor){
			$this->getExecutor()->execute($this->getCommandLine());
			return;
		}
		$this->logCommand();
		if($this->outputEveryLineLive){
			$this->logInfo("OUTPUT:");
		}
		$cmd = $this->getCommandLine();
		$this->response = QMTerminal::builder()
			->in(abs_path())
			->run($cmd);
		$this->response->throw();
		$this->addOutputLine($this->response->output());
		if(!$this->outputEveryLineLive){
			$output = $this->getOutputString();
			$output = self::stripManInMiddleWarning($output);
			if($output !== "Exit status : 0"){
				$this->logInfo("OUTPUT: ".$output);
			}
		}
	}
	/**
	 * @return JenkinsSlave|null
	 */
	public function getExecutor(): ?JenkinsSlave{
		return $this->executor;
	}
	/**
	 * @param JenkinsSlave|null $executor
	 * @return DynamicCommand
	 */
	public function setExecutor(?JenkinsSlave $executor): self{
		$this->executor = $executor;
		return $this;
	}
	private function logCommand(): void{
		$this->logInfo("CMD: ".$this->getCommandLine());
	}
	/**
	 * @param string $live_output
	 */
	private function addOutputLine(string $live_output): void{
		$this->rawOutputLines[] = $live_output;
		if($live_output !== ""){
			$arr = QMStr::explodeNewLines($live_output);
			$message = "\n\t".implode("\n\t", $arr);
			if($this->outputEveryLineLive){
				if($this->obfuscate){
					QMLog::infoWithoutContext($message);
				} else{
					\App\Logging\ConsoleLog::info($message);
				}
			}
			$this->outputLines = array_merge($this->outputLines, $arr);
		}
	}
	public static function stripManInMiddleWarning(string $message): string{
		return trim(QMStr::after("Keyboard-interactive authentication is disabled to avoid man-in-the-middle attacks.",
		                         $message, $message));
	}
	public function getLogMetaData(?array $meta = []): array{ return $meta; }
	/**
	 * @return string
	 */
	public function __toString(){
		return $this->commandLine."\n\t".$this->outputString;
	}
	public function log(){
		$this->logInfo((string)$this);
	}
	public function exceptionIfFailed(){
		$output = $this->getOutputString();
		foreach($this->getExpectedErrorMessages() as $errorMessage){
			if(QMStr::contains($output, $errorMessage)){
				$this->throwException();
			}
		}
		if($this->getExitCode() !== 0) $this->throwException();
	}
	/**
	 * @return string[]
	 */
	public function getExpectedErrorMessages(): array{
		return $this->expectedErrorMessages;
	}
	/**
	 * @param string[] $expectedErrorMessages
	 */
	public function setExpectedErrorMessages(array $expectedErrorMessages): self{
		$this->expectedErrorMessages = $expectedErrorMessages;
		return $this;
	}
	private function throwException(): void{
		le($this->getCommandLine()." FAILED! \nOUTPUT:\n\t".$this->getOutputString(), (array)$this);
	}
	/**
	 * @return int
	 */
	public function getExitCode(): int{
		return $this->code = $this->response->process()->getExitCode();
	}
	/**
	 * @return bool
	 */
	public function isOutputEveryLineLive(): bool{
		return $this->outputEveryLineLive;
	}
	/**
	 * @param bool $outputEveryLineLive
	 * @return DynamicCommand
	 */
	public function setOutputEveryLineLive(bool $outputEveryLineLive): self{
		$this->outputEveryLineLive = $outputEveryLineLive;
		return $this;
	}
}
